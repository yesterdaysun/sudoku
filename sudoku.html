<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sudoku</title>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.13/lodash.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.10/vue.js"></script>
    <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <style>
        .sudoku-container {
            display: flex;
            flex-wrap: wrap;
            width: 330px;
            margin-top: 10px;
        }

        .cell {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 35px;
            height: 35px;
            border: 1px solid black;
            margin-right: -1px;
            margin-bottom: -1px;
            padding: 2px;
        }

        .cell-highlight {
            border: 4px solid red;
        }

        .cell:nth-child(3n+1) {
            margin-right: 0;
        }

        .legend {
            display: flex;
            justify-content: space-around;
            align-items: center;
            width: 35px;
            height: 35px;
            margin-right: -1px;
            margin-bottom: -1px;
            font-weight: bold;
            font-size: 20px;
        }

        .sudoku-row {
            display: flex;
        }

        .sudoku-row:nth-child(3n+1) {
            margin-bottom: 1px;
        }

        .original-number {
            background-color: #d0cece;
            font-weight: bold;
        }

        .unique-number {
            background-color: #e2efda;
        }

        .guess-number {
            background-color: #fff2cc;
        }

        .candidate {
            font-size: 10px;
            line-height: 10px;
        }
    </style>
</head>
<body>
<div id="sudoku" class="container">
    <div class="row">
        <div class="col-sm">
            <h1>Sudoku</h1>
        </div>
    </div>
    <div class="row">
        <div class="col-sm">
            <div class="form-group">
                <label>题目</label>
                <input type="text" class="form-control" v-model="text">
            </div>
            <div class="form-group">
                <label>速度</label>
                <input type="text" class="form-control" v-model="speed">
            </div>
            <button type="button" class="btn btn-primary" @click="solve">
                Solve
            </button>
            <div>
                猜测次数: {{ this.guessCount }}
            </div>
            <div>
                填数次数: {{ this.count }}
            </div>
            <div v-if="grid!=null" class="sudoku-container">
                <div class="sudoku-row">
                    <div class="legend">
                    </div>
                    <div v-for="n in _.range(9)" class="legend">
                        {{ n+1 }}
                    </div>
                </div>
                <div v-for="r in _.range(9)" class="sudoku-row">
                    <div class="legend">
                        {{ String.fromCharCode(r+65) }}
                    </div>
                    <template v-for="c in _.range(9)">
                        <div v-if="grid[r][c].value" class="cell" :class="[grid[r][c].getType(),{'cell-highlight':grid[r][c].highlight}]">
                            {{ grid[r][c].value }}
                        </div>
                        <div v-else-if="grid[r][c].candidates.length==0" class="cell" style="background-color: red;color: white">
                            X
                        </div>
                        <div v-else class="cell" :class="[grid[r][c].getType(),{'cell-highlight':grid[r][c].highlight}]">
                            <template v-for="n in grid[r][c].candidates">
                                {{ n }}
                            </template>
                        </div>
                    </template>
                </div>
            </div>
        </div>
        <div class="col-sm">
            <div class="form-group">
                <label>步骤</label>
                <select size="2" class="form-control" style="height: 600px" :disabled="lockSteps" v-model="step" @change="showStep">
                    <option v-for="step in steps" :value="step.id">
                        {{ step.text }}
                    </option>
                </select>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-sm">
        </div>
    </div>

</div>
<script type="text/javascript">
    function sleep(milliseconds) {
        return new Promise(function (resolve) {
            setTimeout(resolve, milliseconds);
        })
    }

    class Cell {
        constructor(index) {
            this.index = index;
            this.value = null;
            this.candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9];
            this.type = 0;
            this.highlight = false;
        }

        getType() {
            return ["candidate", "original-number", "unique-number", "guess-number"][this.type];
        }
    }

    class Step {
        constructor(id, grid, index, value, text = null) {
            this.id = id;
            this.grid = _.cloneDeep(grid);
            this.index = index;
            this.value = value;
            this.text = text;
            if (!this.text) {
                this.text = this.getText();
            }
        }

        getText() {
            return `[${this.id}] ${String.fromCharCode(this.index[0] + 65)}${this.index[1] + 1} => ${this.value}`;
        }
    }

    class BestPointFinder {
        constructor(sudoku) {
            this.sudoku = sudoku;
            this.name = "BestPointFinder";
        }

        find() {
            let bestCell = null;
            for (let cell of this.sudoku.getCells()) {
                if (cell.candidates === null) {
                    continue;
                }
                if (cell.candidates.length === 0 || cell.candidates.length === 1) {
                    return cell;
                }
                if (bestCell == null || cell.candidates.length < bestCell.candidates.length) {
                    bestCell = cell;
                }
            }
            return bestCell;
        }
    }

    class UniqueCandidateFinder {
        constructor(sudoku) {
            this.sudoku = sudoku;
            this.name = "UniqueCandidateFinder";
        }

        async solve() {
            let hasUniqueSolution = true;
            while (hasUniqueSolution) {
                hasUniqueSolution = false;
                for (let cell of this.sudoku.getCells()) {
                    if (cell.candidates == null) {
                        continue;
                    }
                    if (cell.candidates.length === 0) {
                        return false;
                    }
                    if (cell.candidates.length === 1) {
                        hasUniqueSolution = true;
                        if (!await this.sudoku.SetValueAnimation(cell.index, cell.candidates[0])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
    }

    const FINDERS = [
        UniqueCandidateFinder,
    ]
</script>
<script type="text/javascript">
    let sudoku = {
        text: "..53.....8......2..7..1.5..4....53...1..7...6..32...8..6.5....9..4....3......97..",
        speed: 100,
        grid: null,
        count: 0,
        guessCount: 0,
        steps: [],
        lockSteps: true,
        step: '',
        initGrid: function (text) {
            let nums = text.split("").map(n => n === '.' ? 0 : parseInt(n));
            if (nums.length !== 81) {
                alert("题目错误!");
                return;
            }
            let grid = [];
            this.count = 0;
            this.guessCount = 0;
            this.steps = [];
            this.lockSteps = true;
            for (let r = 0; r < 9; r++) {
                let row = [];
                for (let c = 0; c < 9; c++) {
                    row.push(new Cell([r, c]))
                }
                grid.push(row);
            }
            this.grid = grid;
            let i = 0;
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (nums[i] !== 0) {
                        if (!this.setValue([r, c], nums[i], 1)) {
                            alert("Invalid Sudoku!");
                            throw "Invalid Sudoku!"
                        }
                    }
                    i++;
                }
            }
            this.addStep(null, null, "开局");
        },
        addStep: function (index, value, text = null) {
            this.steps.unshift(new Step(this.steps.length, this.grid, index, value, text));
        },
        setValue: function (index, value, type = 2) {
            this.count += 1;
            let cell = this.grid[index[0]][index[1]];
            cell.value = value;
            cell.candidates = null;
            cell.type = type;
            let valid = true;
            for (let region of this.getRegionsByIndex(index)) {
                let validState = this.discardCandidates(region, [value], [this.getIndexKey(index)]);
                valid = valid && validState;
            }
            if (type !== 1) {
                this.addStep(index, value);
            }
            return valid;
        },
        SetValueAnimation: async function (index, value, type = 2) {
            let valid = this.setValue(index, value, type);
            let speed = parseInt(this.speed) || 100;
            await sleep(speed);
            return valid;
        },
        getCell: function (index) {
            return this.grid[index[0]][index[1]];
        },
        getCells: function* () {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    yield this.grid[r][c];
                }
            }
        },
        getRegions: function () {
            let result = [];
            for (let i of _.range(9)) {
                result.push(this.getRow([i, 0]));
                result.push(this.getCol([0, i]));
                let row = Math.floor(i / 3) * 3;
                let col = (i % 3) * 3;
                result.push(this.getBlock([row, col]));
            }
            return result;
        },
        getRegionsByIndex: function (index) {
            return [this.getRow(index), this.getCol(index), this.getBlock(index)];
        },
        getRow: function (index) {
            return this.grid[index[0]]
        },
        getCol: function (index) {
            return this.grid.map(row => row[index[1]]);
        },
        getBlock: function (index) {
            let [row, col] = index.map(x => Math.floor(x / 3) * 3);
            let result = [];
            for (let r = row; r < row + 3; r++) {
                for (let c = col; c < col + 3; c++) {
                    result.push(this.grid[r][c])
                }
            }
            return result;
        },
        getIndexKey: function (index) {
            return index[0] * 9 + index[1];
        },
        discardCandidates: function (region, candidates, excludeIndexes) {
            let valid = true;
            for (let cell of region) {
                if (cell.candidates && !excludeIndexes.includes(this.getIndexKey(cell.index))) {
                    cell.candidates = _.difference(cell.candidates, candidates);
                    if (cell.candidates.length === 0) {
                        valid = false;
                    }
                }
            }
            return valid;
        },
        isRegionSolved: function (region) {
            let rest = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            for (let cell of region) {
                rest.delete(cell.value);
            }
            return rest.size === 0;
        },
        isAllSet: function () {
            return _.flatten(this.grid).every(cell => cell.value);
        },
        isSolved: function () {
            return this.getRegions().map(r => this.isRegionSolved(r)).every(x => x);
        },
        toPlainText: function () {
            return _.flatten(this.grid).map(cell => cell.value === 0 ? '.' : cell.value).join("");
        }
    };


    let view = new Vue({
        el: '#sudoku',
        data: sudoku,
        methods: {
            solveUniqueSolutions: async function () {
                if (this.isAllSet()) {
                    return true;
                }
                for (let finderCtor of FINDERS) {
                    let finder = new finderCtor(this);
                    if (!await finder.solve()) {
                        return null;
                    }
                    if (this.isAllSet()) {
                        return true;
                    }
                }
                return false;
            },
            dfs: async function () {
                let state = await this.solveUniqueSolutions();
                if (state === null) {
                    return false;
                }
                if (state) {
                    return this.isSolved();
                }
                let bestCell = new BestPointFinder(this).find();

                if (bestCell.candidates.length === 0) {
                    return false;
                }
                this.guessCount += 1;
                for (let n of bestCell.candidates) {
                    let old = _.cloneDeep(this.grid);
                    if (!await this.SetValueAnimation(bestCell.index, n, 3)) {
                        this.grid = old;
                        continue;
                    }
                    if (await this.dfs()) {
                        return true;
                    }
                    this.grid = old;
                }
                return false;
            },
            solve: async function () {
                this.initGrid(this.text);

                if (!await this.dfs()) {
                    alert("Sudoku is wrong");
                    throw "Sudoku is wrong";
                }
                this.addStep(null, null, "结束");
                this.lockSteps = false;
                console.log(`Guess Count: ${this.guessCount}`);
                console.log(`Point Count: ${this.count}`);
                console.log(this.toPlainText());
            },
            showStep: function () {
                let step = this.steps[this.steps.length - this.step - 1];
                this.grid = step.grid;
                if (step.index) {
                    this.getCell(step.index).highlight = true;
                }
            }
        }
    })
</script>
</body>
</html>